<?xml version="1.0" encoding="iso-8859-1" ?> 
<!DOCTYPE muclient> 
<muclient>
<plugin name="LotJRaceBrowser" author="@Johnson" id="a4e8153e52b1b6d490ed4b10" language="Lua" purpose="Browse LotJ Races" save_state="y" requires="4.84" version="1.00">
<description trim="y">
<![CDATA[ 

Sections of this plugin are based on work by Fiendish of Aardwolfmud and other community members.
See 'http://www.gammon.com.au/forum/?id=9385'

To use this plugin:

Type 'racescan' to gather information from the game and populate into the browser.
Type 'raceshow' to display the browser if you previously closed it.
Type 'racehide' or click the X to close the browser.
Type 'raceclear' to clear the stored race information.

This plugin creates a visual index of all current LotJ races. The race list can be sorted by
right clicking anywhere in the window and choosing filters to apply.

  ]]> 
  </description>
  </plugin>
<!--   Get our standard constants   --> 
	<include name="constants.lua" /> 
<!--   Triggers    --> 
<triggers>

  <trigger match="^([\s\d]+)\((\d)\)\> (.*) (\d+)\((\d)\)\> (.*) (\d+)\((\d)\)\> (.*) (\d+)\((\d)\)\> (.*)$" script="raceListScanAdd" regexp="y" enabled="n" group="RacelistScan"  omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger match="^([\s\d]+)\((\d)\)\> (.*) (\d+)\((\d)\)\> (.*) (\d+)\((\d)\)\> (.*)$" script="raceListScanAdd" regexp="y" enabled="n" group="RacelistScan"  omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger match="^([\s\d]+)\((\d)\)\> (.*) (\d+)\((\d)\)\> (.*)$" script="raceListScanAdd" regexp="y" enabled="n" group="RacelistScan"  omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger match="^([\s\d]+)\((\d)\)\> (.*)$" script="raceListScanAdd" regexp="y" enabled="n" group="RacelistScan"  omit_from_output="y" omit_from_log="y" sequence="100" />

  <trigger name="RacelistScanStart" match="^\(L\)egend\: Race Number \(Era Restriction or 0 for none\)\> Race Name $" script="enableRaceListScan" regexp="y" enabled="n"  omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger name="RacelistScanStop" match="^$" script="stopRacelistScan" regexp="y" enabled="n"  omit_from_output="y" omit_from_log="y" sequence="100" />

  <trigger lines_to_match="6"
   match="\(R\)ace\: (.*)\nStr Plus\:([\s\d,-]+)Dex Plus\:([\s\d,-]+)Wis Plus\:([\s\d,-]+)Int Plus\:([\s\d,-]+)\nCon Plus\:([\s\d,-]+)Cha Plus\:([\s\d,-]+)Lck Plus\:([\s\d,-]+)\nHit Pts\:([\s\d]+)AC Mod\:([\s\d,-]+)Frc Plus\:([\s\d,-]+)\nPrice\:([\s\d]+)Deposit\:([\s\d]+)App Only\:(.*)\Z"
   script="addRaceScanFirst"
   multi_line="y"
   regexp="y"
   enabled="n"
   group="raceScanFirst" omit_from_output="y" omit_from_log="y" 
   sequence="100" />
  
  <trigger match="^Players of this race must pick (.*) as their main\.$" script="addRaceMainClass" regexp="y" enabled="n" group="raceScanSecond"  omit_from_output="y" omit_from_log="y" sequence="100" />
  
  <trigger lines_to_match="2" match="\(D\)efault Language\: (.*)\n\(P\)ossible Skincolors\: \Z" script="addRaceScanSecond" multi_line="y" regexp="y" enabled="n" group="raceScanSecond" omit_from_output="y" omit_from_log="y" sequence="100" />
  
  <trigger match="^\((\d+)\)([\w\s]+)\((\d+)\)([\w\s]+)$" script="addSkinColors" regexp="y" group="SkinColors" enabled="n"  omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger match="^\((\d+)\)([\w\s]+)$" script="addSkinColors" regexp="y" group="SkinColors" enabled="n"  omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger match="^$" script="stopSkinColors" regexp="y" group="SkinColors" enabled="n"  omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger match="^(.*) \- (.*)$" script="addExtraAttrib" regexp="y" group="ExtraAttribs" enabled="n"  omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger match="^$" script="stopExtraAttribs" regexp="y" group="ExtraAttribs" enabled="n"  omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger match="^(.*)    (.*)$" script="addRaceLevels" regexp="y" group="RaceLevels" enabled="n"  omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger match="^$" script="stopRaceLevels" regexp="y" group="RaceLevels" enabled="n"  omit_from_output="y" omit_from_log="y" sequence="100" />
  <trigger name="gagAll" match="^(.*)$" regexp="y" keep_evaluating="y" omit_from_output="y" omit_from_log="y" enabled="n" sequence="100" />
</triggers>

<aliases>

	<alias match="racescan" script="startRacelistScan" enabled="y" regexp="n" ignore_case="y" group="LotJRaceBrowser" sequence="100" />
	<alias match="raceclear" script="clearTable" enabled="y" regexp="n" ignore_case="y" group="LotJRaceBrowser" sequence="100" />
	<alias match="raceshow" script="showWindow" enabled="y" regexp="n" ignore_case="y" group="LotJRaceBrowser" sequence="100" />
	<alias match="racehide" script="hideWindow" enabled="y" regexp="n" ignore_case="y" group="LotJRaceBrowser" sequence="100" />
  <alias match="raceprint *" script="printRace" enabled="y" regexp="n" ignore_case="y" group="LotJRaceBrowser" sequence="100" />



</aliases>
<!--   Script    --> 
<script>
<![CDATA[

require "movewindow"
require "copytable"
require "serialize"
require "tprint"
require "pairsByKeys"

 -- enable these to ensure everything works smooth
SetOption("enable_triggers", true)
SetOption("enable_scripts", true)

AUTHOR = GetPluginInfo(GetPluginID(), 2) -- author info
VERSION = string.format("%1.2f", GetPluginInfo(GetPluginID(), 19)) -- version info
win = "win_" .. GetPluginID()  -- unique window name
font = "f"
default_font_name = GetInfo(20)
default_font_size = GetInfo(243)
font_name = GetVariable("font_name") or default_font_name
font_size = tonumber(GetVariable("font_size")) or default_font_size
RESIZE_TAG_SIZE = 10
visible = GetVariable("visible") or "true"
MIN_WIDTH   = 50
MIN_HEIGHT  = 50
MIN_SPLIT   = 75
redraw_scheduled = false


-- default config
default_config = {  height = 300,
            width = 750,
            split = 150, -- location from left for window split
            backcolor = "black",
            }

-- replace default with loaded config
loadstring(GetVariable("config") or "") ()


races = {}
local newRace = {}

raceSelected = -1

raceDisplayedStart = 0
raceDisplayedEnd = 0
raceLineHeight = 0
spacer = 3

text = {}
textStart = 0
textEnd = 0

loadstring(GetVariable("races") or "") ()



function printBrowseList()
  local posy = titleHeight
  local font_height = WindowFontInfo(win, font, 1)
  if #races > 0 then
    for i = raceDisplayedStart, raceDisplayedEnd do
      WindowText (win, font, races[i].name, 5, posy, 0, 0, ColourNameToRGB(((i==raceSelected and "red") or ((races[i].str~=nil and "white") or "darkgray"))))
      posy = posy + font_height + spacer
    end
  end
end

function printRace(name, line, args)
  local num = tonumber(args[1])
  if num then
    if races[num] then
      tprint(races[num])
    end
  end
end

function raceClick()
  hottop = WindowHotspotInfo(win, "leftbackground", 2)
  clickpos = WindowInfo(win, 15)
  raceIndex = math.floor((clickpos-hottop)/raceLineHeight)+raceDisplayedStart  
  updateSelectedRace()
end

function updateRaceText()
  if raceSelected > -1 then -- we chose something
    local race = races[raceSelected]
    if race.price == nil or race.deposit==nil or race.language==nil or race.ac==nil or race.hp==nil or race.apponly==nil or race.str==nil or race.dex==nil or race.con==nil or race.int==nil or race.wis==nil or race.cha==nil or race.frc==nil or race.lck==nil or race.erarestrict==nil then
      -- tried to access while still scanning or invalid scan data
      addText( {"red","Either your race data is invalid or scan is still underway..."}, font, "center")
      textEnd = math.min(textFit, #text)
      return
    end
    if race ~= nil then
      text = {} -- clear the text
      local left = config.split+2
      local top = titleHeight
      local right = config.width-SCROLL_BAR_WIDTH
      local bot = config.height
      local filler = string.rep("-", 20)
      local title_width = WindowTextWidth(win, font, race.name)
      addText( {"white",filler.."Race"..filler}, font, "center")
      addText( {"cyan",race.name}, font, "center")
      
      addText( {"white", filler.."Stats"..filler}, font, "center")
      addText( {"white","Price: ",((race.price==0 and "lime") or "red"),race.price,"white"," Deposit: ",((race.deposit==0 and "lime") or "red"),race.deposit,"white"," Language: ","red",race.language}, font, "center")
      addText( {"white","AC: ","red",race.ac,"white"," Base HP: ","red",race.hp,"white"," App Only: ",((race.apponly=="Yes" and "red") or "lime"),race.apponly}, font, "center")
      addText( {"white","Str: ","red",race.str,"white"," Dex: ","red",race.dex,"white"," Con: ","red",race.con}, font, "center")
      addText( {"white","Int: ","red",race.int,"white"," Wis: ","red",race.wis,"white"," Cha: ","red",race.cha}, font, "center")
      addText( {"white","Frc: ","red",race.frc,"white"," Lck: ","red",race.lck,"white"," Era Restrict: ",((race.erarestrict==0 and "lime") or "red"),race.erarestrict}, font, "center")
      
      addText( {"white",filler.."Levels"..filler}, font, "center")
      addText( {"white","               COM PIL ENG HUN SMU DIP LEA ESP SLI MED SCI"}, font, "center")
      for a, b in pairsByKeys(race.levels) do
        local t = {}
        --t[#t+1]=((b.class==race.mainclass and "cyan") or "white")
        --t[#t+1]=string.format("%14s", b.class)..": "
        t[#t+1]=((a==race.mainclass and "cyan") or "white")
        t[#t+1]=string.format("%14s",a)..": "
        for i, j in ipairs(b.levels) do
          t[#t+1]=((j=="5" and "red") or ((j=="4" and "yellow") or ((j=="3" and "cyan") or ((j=="2" and "lime") or "blue")))) 
          t[#t+1]=" "..j.."  "
        end
        addText( t, font, "center")
      end
      if #race.attribs > 0 then
        addText( {"white",filler.."Extra Arributes"..filler}, font, "center")
        local temp = ""
        for i, j in ipairs(race.attribs) do
          addText( {"lime",j.name,"white"," - ","lime",j.desc}, font, "center")
        end
      end

    textEnd = math.min(textFit, #text)
    end
  end
  
end

function addText(addtext, font, align, pos)
  local line = { t = copytable.deep(addtext), f = font, a = align, p = pos }
  text[#text + 1] = line
end

function drawText()
  --textEnd = math.min(textFit, #text)
  local posy = titleHeight
  local bound = { left = config.split+2, top = titleHeight, right = config.width-SCROLL_BAR_WIDTH, bot = config.height-2 } -- valid bounding box for drawing


  if #text >= 1 then
    for i = textStart, textEnd do
      v = text[i]
      if v~=nil then
        local pos = {}
        local alltext = ""
        for a, b in ipairs(v.t) do
          if math.fmod(a-1, 2)==1 then -- text
            alltext = alltext..b
          end
        end

      local textWidth = WindowTextWidth(win, v.f, alltext)
      local textHeight = WindowFontInfo(win, v.f, 1)
      if v.a == "left" then
        pos = { left = bound.left, top = posy, right = bound.left+textWidth, bot = posy+textHeight }
      elseif v.a == "center" then
        pos = { left = (bound.left+((bound.right-bound.left)/2))-(textWidth/2), top = posy, right = (bound.left+((bound.right-bound.left)/2))+(textWidth/2), bot = posy+textHeight }
      elseif v.a == "right" then
        pos = { left = bound.right-textWidth, top = posy, right = bound.right, bot = posy+textHeight }
      else
        pos = v.p
      end
      local colour = ""
      for a, b in ipairs(v.t) do
        if math.fmod(a-1, 2)==0 then -- got the colour
          colour = b
        elseif math.fmod(a-1, 2)==1 then -- got the text
          tWidth = WindowTextWidth(win, v.f, b)
          pos.left = pos.left + WindowText(win, v.f, b, pos.left, pos.top, pos.left+tWidth, pos.bot, ColourNameToRGB(colour))
        end
      end

      posy = posy + textLineHeight
    end
  end
  end

end

function findBestClass(levels)
  local best = 0
  

end

function addLevels(list)
  local total = 0
  for i, v in pairs(list) do
    total = total + v
  end
  return total
end

function raceListScanAdd(name, line, args)
  local race = {}
  for i, v in pairs(args) do
    if math.fmod(i-1, 3)==0 then -- index
      race.index = tonumber(v)
      --Note("found race index: "..v)
    elseif math.fmod(i-1, 3)==1 then -- era restrict
      race.erarestrict = tonumber(v)
      --Note("found era restrict: "..v)
    elseif math.fmod(i-1, 3)==2 then -- race name
      race.name = Trim(v)
      --Note("found race name: "..v)
      races[#races + 1] = race
      race = {}
    end
  end

end

function startRacelistScan(name, line, args)
  races = {}
  SendNoEcho("showrace")
  EnableTrigger("RacelistScanStart", true)
  EnableTrigger("gagAll", true)
  ColourNote("yellow", "", "Racelist Scan started...")

end

function enableRaceListScan(name, line, args)
  EnableTriggerGroup("RacelistScan", true)
  EnableTrigger("RacelistScanStart", false)
  EnableTrigger("RacelistScanStop", true)
  
end

function stopRacelistScan(name, line, args)
  EnableTriggerGroup("RacelistScan", false)
  EnableTrigger("RacelistScanStart", false)
  EnableTrigger("RacelistScanStop", false)
  ColourNote("yellow", "", "Racelist Scan complete. Found "..#races.." races.")
  races.scantime = os.time()
  SetUpHotspotsAndDraw(false)
  --tprint(races)
  startRaceScan()
end

local currentRace = {}
local currentRaceIndex = 0
local skinColors = {}
local extraAttribs = {}
local raceLevels = {{}}

function startRaceScan(name, line, args)
  currentRaceIndex = 0
  ColourNote("yellow", "", "Race Scan started...\n\n")
  scanNextRace()
end

function scanNextRace(name, line, args)
  currentRaceIndex = currentRaceIndex + 1
  if currentRaceIndex > #races then
    ColourNote("yellow","","Race Scan complete.")
    EnableTrigger("gagAll", false)
    --tprint(races)
  else
    currentRace = races[currentRaceIndex]
    DeleteLines(2)
    ColourNote("silver","","Scan "..string.format("%2.2f",((currentRaceIndex/#races)*100)).."% completed.")
    SendNoEcho("showrace "..currentRace.index)
    EnableTriggerGroup("raceScanFirst", true)
  end
  scheduleRedraw()
end

function sortByAlpha()
  table.sort(races, function (k1, k2) return k1.name < k2.name end )
  clearFilters()
  updateSelectedRace()
end

function sortByFilter(class, filter, stats)
  table.sort(races, function (k1, k2) return getSubclassLevelsByClass(k1, class, filter, stats) > getSubclassLevelsByClass(k2, class, filter, stats) end )
  updateSelectedRace()
end

function clearFilters()
  filter_main_class = ""
  filter_classes = {}
  filter_stats = {}
end
  

function updateSelectedRace()
  if races[raceIndex] ~= nil then
    raceSelected = raceIndex
    updateRaceText()
    forceRedraw()
  end
end

class_matrix = {  ["combat"] = 1, 
                        ["piloting"] = 2, 
                        ["engineering"] = 3, 
                        ["bounty hunting"] = 4, 
                        ["smuggling"] = 5, 
                        ["diplomacy"] = 6, 
                        ["leadership"] = 7, 
                        ["espionage"] = 8, 
                        ["slicer"] = 9, 
                        ["medical"] = 10, 
                        ["science"] = 11 }
                        
matrix_class = { "combat", "piloting", "engineering", "bounty hunting", "smuggling", "diplomacy", "leadership", "espionage", "slicer", "medical", "science" }
matrix_stats = { "price", "deposit", "str", "dex", "con", "int", "wis", "cha", "frc", "lck", "ac", "hp", "apponly", "erarestrict" }

function getSubclassLevelsByClass(r, c, s, st)
  local num = 0
  if type(s)=="table" then
    for i, v in ipairs(s) do
      if c=="" then -- we didn't specify a class, take the average
        for a=1, 11 do
          num = num + r.levels[matrix_class[a]].levels[class_matrix[v]]
        end
        num = num / 11
      else
        num = num + r.levels[c].levels[class_matrix[v]]
      end
    end
  end
  if st~=nil then
    if type(st)=="table" then
      for i, v in ipairs(st) do
        num = num + getRaceStat(r, v)
      end
    end
  end
  return num
end

function getRaceStat(r, s)
  if r[s] ~= nil then
    if s=="price" or s=="deposit" then -- normalize price and deposit to be in line with stats
      return -r[s]/1000
    elseif s=="apponly" then -- convert apponly into a number
      return ((r[s]=="Yes" and 10) or 0)
    elseif s=="ac" then -- convert ac to positive and normalize
      return -r[s]/25
    elseif s=="hp" then -- normalize hp
      return r[s]/250
    else
      return r[s]
    end
  end
end

function addRaceScanFirst(name, line, args)
-- "\(R\)ace\: (.*)\nStr Plus\: ([\s\d,-]+) Dex Plus\: ([\s\d,-]+) Wis Plus\: ([\s\d,-]+) Int Plus\: ([\s\d,-]+) \nCon Plus\: ([\s\d,-]+) Cha Plus\: ([\s\d,-]+) Lck Plus\: ([\s\d,-]+) \nHit Pts\: ([\s\d,-]+)AC Mod\: ([\s\d,-]+) Frc Plus\: ([\s\d,-]+) \nPrice\: ([\s\d,-]+)Deposit\: ([\s\d,-]+)App Only\: (.*)\n\(D\)efault Language\: (.*)\n\(P\)ossible Skincolors\:\Z"
  if currentRace.name ~= args[1] then
    ColourNote("red","","Mismatched race names detected ("..currentRace.name.."~="..args[1]..") aborting...")
    stopRaceScan()
    return
  end
  currentRace.str = tonumber(args[2])
  currentRace.dex = tonumber(args[3])
  currentRace.wis = tonumber(args[4])
  currentRace.int = tonumber(args[5])
  currentRace.con = tonumber(args[6])
  currentRace.cha = tonumber(args[7])
  currentRace.lck = tonumber(args[8])
  currentRace.hp =  tonumber(args[9])
  currentRace.ac =  tonumber(args[10])
  currentRace.frc = tonumber(args[11])
  currentRace.price = tonumber(args[12])
  currentRace.deposit = tonumber(args[13])
  currentRace.apponly = Trim(args[14])
  --currentRace.language = Trim(args[15])
  --races[currentRaceIndex] = currentRace
  EnableTriggerGroup("raceScanFirst", false)
  DeleteLines(1)
  startRaceScanSecond()
end

function addRaceMainClass(name, line, args)
  currentRace.mainclass = args[1]
end

function startRaceScanSecond(name, line, args)
  EnableTriggerGroup("raceScanSecond", true)
end
function addRaceScanSecond(name, line, args)
  currentRace.language = Trim(args[1])
  EnableTriggerGroup("raceScanSecond", false)
  startSkinColors()
end

function startSkinColors(name, line, args)
  skinColors = {}
  EnableTriggerGroup("SkinColors", true)
end

function addSkinColors(name, line, args)
  local color = {}
  for i, v in pairs(args) do
    if math.fmod(i-1, 2)==0 then -- index
      color.index = tonumber(v)
      --Note("found race index: "..v)
    elseif math.fmod(i-1, 2)==1 then -- name
      color.name = Trim(v)
      --Note("found era restrict: "..v)
      skinColors[#skinColors + 1] = color
      color = {}
    end
  end
end

function stopSkinColors(name, line, args)
  EnableTriggerGroup("SkinColors", false)
  currentRace.skincolors = copytable.deep(skinColors)
  startExtraAttribs()
end

function startExtraAttribs(name, line, args)
  extraAttribs = {}
  EnableTriggerGroup("ExtraAttribs", true)
end

function addExtraAttrib(name, line, args)
  local attrib = { name = Trim(args[1]), desc = Trim(args[2]) }
  extraAttribs[#extraAttribs + 1] = attrib
end
  

function stopExtraAttribs(name, line, args)
  EnableTriggerGroup("ExtraAttribs", false)
  currentRace.attribs = copytable.deep(extraAttribs)
  startRaceLevels()
end

function startRaceLevels(name, line, args)
  raceLevels = {}
  EnableTriggerGroup("RaceLevels", true)
end

function addRaceLevels(name, line, args)
  local levels = {}
  --levels.class = Trim(args[1])
  args[2] = string.gsub(Trim(args[2]), "   ", " ")
  levels.levels = utils.split(Trim(args[2]), " ")
  --raceLevels[#raceLevels + 1] = levels
  raceLevels[Trim(args[1])] = levels
end

function stopRaceLevels(name, line, args)
  EnableTriggerGroup("RaceLevels", false)
  currentRace.levels = copytable.deep(raceLevels)
  races[currentRaceIndex] = currentRace
  scanNextRace()
end

function stopRaceScan(name, line, args)
  EnableTriggerGroup("raceScanFirst", false)
  EnableTriggerGroup("SkinColors", false)
  EnableTriggerGroup("ExtraAttribs", false)
  EnableTriggerGroup("RaceLevels", false)
  EnableTrigger("gagAll", false)
end

function getRaceByIndex(index)
  for i, v in pairs(races) do
    if i==index then
      return v
    end
  end
  ColourNote("red","","Error, no race with that index ("..index..")")
  return
end

function beginScan(name, line, args)
end
function clearTable(name, line, args)
  races = {}
  text = {}
  config = default_config
  ColourNote("yellow","","Race list tables cleared.")
  OnPluginSaveState()
  SetUpHotspotsAndDraw(true)
end

function showWindow(name, line, args)
  visible = "true"
  scheduleRedraw()
end
function hideWindow(name, line, args)
  visible = "false"
  WindowShow(win, false)
end

function setupWindow(name, line, args)


end

SCROLL_BACKGROUND_COLOUR = 0xE8E8E8
SCROLL_BAR_COLOUR = 0x111111
SCROLL_DETAIL_COLOUR = 0x000000
SCROLL_BAR_WIDTH = 15

titleHeight = 0


function drawWindow(name, line, args)
	WindowRectOp (win, miniwin.rect_fill, 0, 0, config.width, config.height, ColourNameToRGB(config.backcolor))  -- draw blank rectangle to "erase" window contents
  -- drag handler
  movewindow.add_drag_handler (win, 0, 0, config.width-30, titleHeight)		

	 -- draw border
  WindowRectOp (win, miniwin.rect_draw_edge, 0, 0, 0, 0, miniwin.rect_edge_etched, miniwin.rect_edge_at_all)
  WindowRectOp (win, miniwin.rect_frame, 1, titleHeight, config.split, config.height-1, ColourNameToRGB("white"))
	WindowRectOp (win, miniwin.rect_frame, config.split+1, titleHeight, config.width-1, config.height-1, ColourNameToRGB("white"))

  printBrowseList()
    
  drawText()
  
  -- draw scrollbars
  drawScrollbars()
    
    
  -- draw X in the corner to close the window
  --WindowRectOp(win, 5, config.width-15, 1, config.width, titleHeight, 5, 15+ 0x0800)
  WindowLine (win, config.width-15, 5, config.width-5, 15, ColourNameToRGB ("white"), miniwin.pen_solid, 1)
  WindowLine (win, config.width-15, 15, config.width-5, 5, ColourNameToRGB ("white"), miniwin.pen_solid, 1)
  WindowAddHotspot(win, "windowX", 
        config.width-15, 5, config.width-5, 15,
  			"",                   --mousehover
  			"",                   --mouseoffhover
  			"destroyWindow",      --mousedown
  			"CancelMouseDown",                   --mouseoffdown
  			"LeftClickOnly",                   --mouseup
  			"Close race browser window",
  			1, 0)
  -- heading line
 	WindowText (win, font, "LotJ Race Browser v"..VERSION, 3, 3, 0, 0, ColourNameToRGB  "white")
  drawRefreshButton()
  drawResizer(win, config.width, config.height)
  WindowShow (win,  true)
  --BroadcastPlugin(999, "repaint")
  
  
end

function drawRefreshButton()
  local display = ""
  if races.scantime then
    local daysold = tonumber(string.format("%1.0f", os.difftime(os.time(), tonumber(races.scantime))/86400))
    display = "Race data is "..((daysold>0 and daysold.." day"..((daysold>1 and "s")or "").." old") or "current")
  else
    display = "No race data"
  end
  WindowText(win, font, display, config.width-WindowTextWidth(win, font, display)-40, 3, 0, 0, ColourNameToRGB("white"))

  WindowAddHotspot(win, "refreshbutton", config.width-30, 1, config.width-15, titleHeight, "", "", "startRacelistScan", "", "", "Update race data", 1, 0)
  points = string.format("%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i", config.width-23, titleHeight-12, config.width-19, titleHeight-8, config.width-21,titleHeight-8,config.width-21, titleHeight-3,config.width-25, titleHeight-3,config.width-25,titleHeight-8,config.width-27, titleHeight-8)
  WindowPolygon(win, points, ColourNameToRGB("white"), 0, 1, ColourNameToRGB("white"), 0, true, false)
  

end

function drawScrollbars(name, line, args)

   -- left Scrollbar base
   WindowRectOp(win, 2, config.split-2-SCROLL_BAR_WIDTH, titleHeight, config.split-2, config.height-2, SCROLL_BACKGROUND_COLOUR) -- scroll bar background
   WindowRectOp(win, 1, config.split-2-SCROLL_BAR_WIDTH+1, SCROLL_BAR_WIDTH+titleHeight+1, config.split-2-1, config.height-SCROLL_BAR_WIDTH-1, SCROLL_DETAIL_COLOUR) -- scroll bar background inset rectangle
   
   -- right Scrollbar base
   WindowRectOp(win, 2, config.width-SCROLL_BAR_WIDTH, titleHeight, config.width, -SCROLL_BAR_WIDTH, SCROLL_BACKGROUND_COLOUR) -- scroll bar background
   WindowRectOp(win, 1, config.width-SCROLL_BAR_WIDTH+1, SCROLL_BAR_WIDTH+titleHeight+1, config.width-1, config.height-(2*SCROLL_BAR_WIDTH)-1, SCROLL_DETAIL_COLOUR) -- scroll bar background inset rectangle

   
   -- draw right scrollbar up and down arrows

   if (keepscrolling == "rightup") then
      -- draw top scroll button pressed
      WindowRectOp(win, 5, (config.width-SCROLL_BAR_WIDTH), titleHeight, 0, titleHeight+SCROLL_BAR_WIDTH, 10,  15 + 0x800) -- up arrow pushed
      points = string.format("%i,%i,%i,%i,%i,%i", (config.width-SCROLL_BAR_WIDTH)+3, titleHeight+9,(config.width-SCROLL_BAR_WIDTH)+7, titleHeight+5,(config.width-SCROLL_BAR_WIDTH)+11, titleHeight+9)
      WindowPolygon(win, points,
         0x000000, 0, 1, -- pen (solid, width 1)
         0x000000, 0, -- brush (solid)
         true, -- close
         false) -- alt fill
   else
      -- draw top scroll button unpressed
      WindowRectOp(win, 5, (config.width-SCROLL_BAR_WIDTH), titleHeight, config.width, titleHeight+SCROLL_BAR_WIDTH, 5, 15 + 0x800)
      points = string.format("%i,%i,%i,%i,%i,%i", (config.width-SCROLL_BAR_WIDTH)+3, titleHeight+9,(config.width-SCROLL_BAR_WIDTH)+7, titleHeight+5,(config.width-SCROLL_BAR_WIDTH)+11, titleHeight+9)
      WindowPolygon(win, points,
         0x000000, 0, 1,   -- pen (solid, width 1)
         0x000000, 0, --brush (solid)
         true, --close
         false)  --alt fill
   end
    
   if (keepscrolling == "rightdown") then
      -- draw bottom scroll button pressed
      WindowRectOp(win, 5, (config.width-SCROLL_BAR_WIDTH), config.height-(SCROLL_BAR_WIDTH*2), 0, config.height-SCROLL_BAR_WIDTH-1, 10,  15 + 0x800) 
      points = string.format("%i,%i,%i,%i,%i,%i", (config.width-SCROLL_BAR_WIDTH)+3, (config.height-SCROLL_BAR_WIDTH)-11,(config.width-SCROLL_BAR_WIDTH)+7, (config.height-SCROLL_BAR_WIDTH)-7, (config.width-SCROLL_BAR_WIDTH)+11,(config.height-SCROLL_BAR_WIDTH)-11)
      WindowPolygon(win, points,
         0x000000, 0, 1, -- pen (solid, width 1)
         0x000000, 0, -- brush (solid)
         true, -- close
         false) -- alt fill
   else
      -- draw bottom scroll button unpressed
      WindowRectOp(win, 5, (config.width-SCROLL_BAR_WIDTH), config.height-(SCROLL_BAR_WIDTH*2), config.width, config.height-SCROLL_BAR_WIDTH, 5,  15 + 0x800)
      points = string.format("%i,%i,%i,%i,%i,%i", (config.width-SCROLL_BAR_WIDTH)+3, (config.height-SCROLL_BAR_WIDTH)-11,(config.width-SCROLL_BAR_WIDTH)+7, (config.height-SCROLL_BAR_WIDTH)-7, (config.width-SCROLL_BAR_WIDTH)+11,(config.height-SCROLL_BAR_WIDTH)-11)
      WindowPolygon(win, points,
         0x000000, 0, 1,   -- pen (solid, width 1)
         0x000000, 0, --brush (solid)
         true, --close
         false) --alt fill
   end
   
      -- draw left scrollbar up and down arrows

   if (keepscrolling == "leftup") then
      -- draw top scroll button pressed
      WindowRectOp(win, 5, (config.split-SCROLL_BAR_WIDTH-2), titleHeight, config.split-2, titleHeight+SCROLL_BAR_WIDTH, 10,  15 + 0x800) -- up arrow pushed
      points = string.format("%i,%i,%i,%i,%i,%i", (config.split-SCROLL_BAR_WIDTH-2)+3, titleHeight+9,(config.split-SCROLL_BAR_WIDTH-2)+7, titleHeight+5,(config.split-SCROLL_BAR_WIDTH-2)+11, titleHeight+9)
      WindowPolygon(win, points,
         0x000000, 0, 1, -- pen (solid, width 1)
         0x000000, 0, -- brush (solid)
         true, -- close
         false) -- alt fill
   else
      -- draw top scroll button unpressed
      WindowRectOp(win, 5, (config.split-SCROLL_BAR_WIDTH-2), titleHeight, config.split-2, titleHeight+SCROLL_BAR_WIDTH, 5, 15 + 0x800)
      points = string.format("%i,%i,%i,%i,%i,%i", (config.split-SCROLL_BAR_WIDTH-2)+3, titleHeight+9,(config.split-SCROLL_BAR_WIDTH-2)+7, titleHeight+5,(config.split-SCROLL_BAR_WIDTH-2)+11, titleHeight+9)
      WindowPolygon(win, points,
         0x000000, 0, 1,   -- pen (solid, width 1)
         0x000000, 0, --brush (solid)
         true, --close
         false)  --alt fill
   end
    
   if (keepscrolling == "leftdown") then
      -- draw bottom scroll button pressed
      WindowRectOp(win, 5, (config.split-SCROLL_BAR_WIDTH-2), config.height-SCROLL_BAR_WIDTH, config.split-2, config.height-1, 10,  15 + 0x800) 
      points = string.format("%i,%i,%i,%i,%i,%i", (config.split-SCROLL_BAR_WIDTH-2)+3, config.height-11,(config.split-SCROLL_BAR_WIDTH-2)+7, config.height-7, (config.split-SCROLL_BAR_WIDTH-2)+11,config.height-11)
      WindowPolygon(win, points,
         0x000000, 0, 1, -- pen (solid, width 1)
         0x000000, 0, -- brush (solid)
         true, -- close
         false) -- alt fill
   else
      -- draw bottom scroll button unpressed
      WindowRectOp(win, 5, (config.split-SCROLL_BAR_WIDTH-2), config.height-SCROLL_BAR_WIDTH, config.split-2, config.height, 5,  15 + 0x800)
      points = string.format("%i,%i,%i,%i,%i,%i", (config.split-SCROLL_BAR_WIDTH-2)+3, config.height-11,(config.split-SCROLL_BAR_WIDTH-2)+7, config.height-7, (config.split-SCROLL_BAR_WIDTH-2)+11,config.height-11)
      WindowPolygon(win, points,
         0x000000, 0, 1,   -- pen (solid, width 1)
         0x000000, 0, --brush (solid)
         true, --close
         false) --alt fill
   end
   
   
    -- determine left scrollbar position indicator

    totalSteps = #races
    if (totalSteps <= racesFit-1) then
       totalSteps = 1
    end
    SCROLL_BAR_HEIGHT = (config.height-(2*SCROLL_BAR_WIDTH)-titleHeight)
    if (not dragscrolling) then
      stepNum = raceDisplayedStart-1
      barPos = SCROLL_BAR_WIDTH + titleHeight + ((SCROLL_BAR_HEIGHT/totalSteps) * stepNum)
      barSize = (SCROLL_BAR_HEIGHT/math.max(racesFit-1,totalSteps)) * (racesFit-1)
      if barSize < 10 then
        barSize = 10
      end
      if barPos+barSize > SCROLL_BAR_WIDTH+titleHeight+SCROLL_BAR_HEIGHT then
        barPos = SCROLL_BAR_WIDTH+titleHeight+SCROLL_BAR_HEIGHT - barSize
      end
      WindowAddHotspot(win, "leftscroller", (config.split-SCROLL_BAR_WIDTH-2), barPos, config.split-2, barPos+barSize, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)
      WindowDragHandler(win, "leftscroller", "ScrollerMoveCallback", "ScrollerReleaseCallback", 0)
    
    end
    WindowRectOp(win, 5, (config.split-SCROLL_BAR_WIDTH-2), barPos, config.split-2, barPos+barSize, 5, 15 + 0x800) -- scrollbar position indicator
    
    
   -- determine right scrollbar position indicator
   totalSteps2 = #text
   if (totalSteps2 <= textFit-1) then
      totalSteps2 = 1 
   end
   SCROLL_BAR_HEIGHT2 = (config.height-(3*SCROLL_BAR_WIDTH)-titleHeight)
   if (not dragscrolling) then
      stepNum2 = textStart-1
      barPos2 = SCROLL_BAR_WIDTH +titleHeight+ ((SCROLL_BAR_HEIGHT2/totalSteps2) * stepNum2)
      barSize2 = (SCROLL_BAR_HEIGHT2/math.max(textFit-1,totalSteps2)) * (textFit-1)
      if barSize2 < 10 then
         barSize2 = 10
      end
      if barPos2+barSize2 > SCROLL_BAR_WIDTH+titleHeight+SCROLL_BAR_HEIGHT2 then
         barPos2 = SCROLL_BAR_WIDTH+titleHeight+SCROLL_BAR_HEIGHT2 - barSize2
      end
      WindowAddHotspot(win, "rightscroller", (config.width-SCROLL_BAR_WIDTH), barPos2, config.width, barPos2+barSize2, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)
      WindowDragHandler(win, "rightscroller", "ScrollerMoveCallback", "ScrollerReleaseCallback", 0)
   end
   WindowRectOp(win, 5, (config.width-SCROLL_BAR_WIDTH), barPos2, config.width, barPos2+barSize2, 5, 15 + 0x800) -- scrollbar position indicator
    
end

function destroyWindow(name, list, args)
	WindowShow (win, false)
	visible = "false"
end

function scheduleRedraw()
	if redraw_scheduled == false then
		redraw_scheduled = true
		DoAfterSpecial(0.1, 'drawWindows()', sendto.script)
	end
end

function forceRedraw()
  if redraw_scheduled == false then
    redraw_scheduled = true
    drawWindows()
  end
end

function wheel_move (flags, hotspot_id)
  if hotspot_id == "leftbackground" then
    if bit.band(flags, 0x100) ~= 0 then
      if raceDisplayedStart < #races-racesFit+2 then
        -- down
        raceDisplayedStart = math.max(1, math.min(#races-racesFit+2, raceDisplayedStart+3))
        raceDisplayedEnd = math.min(#races, raceDisplayedStart+racesFit-2)    
        forceRedraw()
      end
    elseif raceDisplayedStart > 1 then
      -- up
      raceDisplayedStart = math.max(1, raceDisplayedStart-3)
      raceDisplayedEnd = math.min(#races, raceDisplayedStart+racesFit-2)
      forceRedraw()
    end
  elseif hotspot_id == "rightbackground" then
    if bit.band(flags, 0x100) ~= 0 then
      if textStart < #text-textFit+2 then
        -- down
        textStart = math.max(1, math.min(#text-textFit+2, textStart+3))
        textEnd = math.min(#text, textStart+textFit-2)    
        forceRedraw()
      end
    elseif textStart > 1 then
      -- up
      textStart = math.max(1, textStart-3)
      textEnd = math.min(#text, textStart+textFit-2)
      forceRedraw()
    end

  end
end -- wheel_move


function ScrollerMoveCallback(flags, hotspot_id)
  mouseposy = WindowInfo(win, 18)
  windowtop = WindowInfo(win, 2)
  if hotspot_id == "leftscroller" then
    barPos = math.max(mouseposy-windowtop+clickdelta, SCROLL_BAR_WIDTH+titleHeight)
    if barPos > config.height-(SCROLL_BAR_WIDTH)-barSize then
      barPos = config.height-(SCROLL_BAR_WIDTH)-barSize
      raceDisplayedStart = math.max(1,#races-racesFit+2)
      raceDisplayedEnd = #races
    else
      raceDisplayedStart = math.max(1,math.floor((barPos-SCROLL_BAR_WIDTH-titleHeight)/(SCROLL_BAR_HEIGHT/totalSteps)+1))
      raceDisplayedEnd = math.min(raceDisplayedStart + racesFit-2, #races)
    end
  elseif hotspot_id == "rightscroller" then
    barPos2 = math.max(mouseposy-windowtop+clickdelta, SCROLL_BAR_WIDTH+titleHeight)
    if barPos2 > config.height-(SCROLL_BAR_WIDTH*2)-barSize2 then
      barPos2 = config.height-(SCROLL_BAR_WIDTH*2)-barSize2
      textStart = math.max(1,#text-textFit+2)
      textEnd = #text
    else
      textStart = math.max(1,math.floor((barPos2-SCROLL_BAR_WIDTH-titleHeight)/(SCROLL_BAR_HEIGHT/totalSteps2)+1))
      textEnd = math.min(textStart + textFit-2, #text)
    end
  end
  scheduleRedraw()
end

function ScrollerReleaseCallback(flags, hotspot_id)
   dragscrolling = false
   scheduleRedraw()
end

----------------------------------------------------------------------
-- Called as resizer is dragged.
----------------------------------------------------------------------
function ResizeMoveCallback(flags, hotspot_id)
   posx, posy = WindowInfo (win, 17), WindowInfo (win, 18)
   config.width = config.width + posx - startposx
   startposx = posx
   if (config.width < MIN_WIDTH) then
      config.width = MIN_WIDTH
      startposx = windowinfo.window_left+config.width
   elseif (windowinfo.window_left+config.width > GetInfo(281)) then
      config.width = GetInfo(281)-windowinfo.window_left
      startposx = GetInfo(281)
   end
   
   config.height = config.height + posy - startposy
   startposy = posy
   if (config.height < MIN_HEIGHT) then
   	config.height = MIN_HEIGHT
   	startposy = windowinfo.window_top+config.height
   elseif (windowinfo.window_top+config.height > GetInfo(280)) then
   	config.height = GetInfo(280)-windowinfo.window_top
   	startposy = GetInfo(280)
   end
   
   
	if (utils.timer() - lastRefresh > 0.0333) then
		SetUpHotspotsAndDraw(false)
		lastRefresh = utils.timer()
	end
end
lastRefresh = 0
---------------------------------------------------------------------------------
-- Called after the resize widget is released.
---------------------------------------------------------------------------------
function ResizeReleaseCallback ()
  config.height = titleHeight+(raceLineHeight*(racesFit-1))+3 -- snap height down to not have dead space after last line
  SetUpHotspotsAndDraw(false) -- true here causes old lines to re-wrap at the new size
end
---------------------------------------------------------------------------------
-- Called as window split is being dragged.
---------------------------------------------------------------------------------
function SplitMoveCallback(flags, hotspot_id)
  posx = WindowInfo(win, 17)
  config.split = config.split + posx - startposx
  startposx = posx
  if (config.split < MIN_SPLIT) then
    config.split = MIN_SPLIT
    startposx = windowinfo.window_left+config.split
  elseif (windowinfo.window_left+config.split > GetInfo(281)) then -- prevent moving split off right edge of screen
    config.split = GetInfo(281)-windowinfo.window_left
    startposx = GetInfo(281)
  end
  
  if (utils.timer() - lastRefresh > 0.0333) then
		SetUpHotspotsAndDraw(false)
		lastRefresh = utils.timer()
	end
end
---------------------------------------------------------------------------------
-- Called after window split is released.
---------------------------------------------------------------------------------
function SplitReleaseCallback()
  SetUpHotspotsAndDraw(false)
end
---------------------------------------------------------------------------------
-- Called when mouse button is pressed on hotspot.
---------------------------------------------------------------------------------
function MouseDown(flags, hotspot_id)
  if (hotspot_id == "resize" or hotspot_id == "splitmove") then
    startposx, startposy = WindowInfo (win, 17), WindowInfo (win, 18)
  elseif (hotspot_id == "leftscroller") then
    clickdelta = WindowHotspotInfo(win, "leftscroller", 2)-WindowInfo (win, 15)
    dragscrolling = true
  elseif (hotspot_id == "rightscroller") then
    clickdelta = WindowHotspotInfo(win, "rightscroller", 2)-WindowInfo (win, 15)
    dragscrolling = true
  elseif (hotspot_id == "leftup" or hotspot_id == "leftdown") then
    keepscrolling = hotspot_id
    scrollbar()
  elseif (hotspot_id == "rightup" or hotspot_id == "rightdown") then
    keepscrolling = hotspot_id
    scrollbar2()
  elseif (hotspot_id == "leftbackground") then
    raceClick()
  end
end
---------------------------------------------------------------------------------
-- Called when mouse moved away from hotspot. Doesn't really apply for draggables.
---------------------------------------------------------------------------------
function CancelMouseDown(flags, hotspot_id)
  keepscrolling = ""
  scheduleRedraw()
end
---------------------------------------------------------------------------------
-- Called when mouse button released on hotspot.
---------------------------------------------------------------------------------
function MouseUp(flags, hotspot_id, win)
   if bit.band (flags, miniwin.hotspot_got_rh_mouse) ~= 0 then
      right_click_menu()
   end
   keepscrolling = ""
   return true
end
function LeftClickOnly(flags, hotspot_id, win)
	if bit.band (flags, miniwin.hotspot_got_rh_mouse) ~= 0 then
    return true
	end
	return false
end

filter_main_class = ""
filter_classes = {}
filter_stats = {}

function right_click_menu(hotspot_id)

	menu ="!"
  menu = menu .."^Race Sorting|>Apply main class filter|"
  
  for i, v in ipairs(matrix_class) do
    menu = menu..((filter_main_class==v and "+") or "")..v.."|"
  end
  menu = menu.."<|>Apply level filters|"
  for i, v in ipairs(matrix_class) do
    local found = false
    for k, j in pairs(filter_classes) do
      if j==v then -- class belongs to sorting filter
        found = true
      end
    end
    menu = menu..((found and "+") or "")..v.."|"
  end
  menu = menu.."<|>Apply stat filters|"
  for i, v in ipairs(matrix_stats) do
    local found = false
      for k, j in pairs(filter_stats) do
        if j==v then -- stat belongs to sorting filter
          found = true
        end
      end
    menu = menu..((found and "+") or "")..v.."|"
  end
  menu = menu .. "<|Sort alphabetically|Clear filters"
  
  result = tonumber(WindowMenu (win,
		WindowInfo (win, 14),  -- x position
		WindowInfo (win, 15),   -- y position
		menu))
    
    
  if result~=nil then
    if result > 0 and result <= #matrix_class then -- chose a main class
      if filter_main_class==matrix_class[result] then -- remove main class choice
        filter_main_class = ""
      else
        filter_main_class = matrix_class[result]
      end
    elseif result > #matrix_class and result <= #matrix_class*2 then -- chose a level filter
      local choice = matrix_class[result-#matrix_class]
      local found = 0
      for k, v in pairs(filter_classes) do
        if v==choice then -- choice already in filter, remove it
          found = k
        end
      end
      if found>0 then
        table.remove(filter_classes, found)
      else
        filter_classes[#filter_classes + 1] = choice
      end
    elseif result > #matrix_class*2 and result <= #matrix_class*2+#matrix_stats then -- chose a stat filter
      local choice = matrix_stats[result-#matrix_class*2]
      local found = 0
      for k, v in pairs(filter_stats) do
        if v==choice then -- choice already in filter, remove it
          found = k
        end
      end
      if found>0 then
        table.remove(filter_stats, found)
      else
        filter_stats[#filter_stats + 1] = choice
      end
    elseif result == #matrix_class*2+#matrix_stats+1 then -- chose alpha sort
      sortByAlpha()
      return
    elseif result == #matrix_class*2+#matrix_stats+2 then -- chose clear filters
      clearFilters()
      return
    end
    sortByFilter(filter_main_class, filter_classes, filter_stats)
  end

end

keepscrolling = ""
require "wait"

function scrollbar()
   wait.make(
   function()
      while keepscrolling == "leftup" or keepscrolling == "leftdown" do
         if keepscrolling == "leftup" then
            if (raceDisplayedStart > 1) then
               raceDisplayedStart = raceDisplayedStart - 1
               raceDisplayedEnd = raceDisplayedEnd - 1
            else
                 keepscrolling = ""
            end
         elseif keepscrolling == "leftdown" then
            if (raceDisplayedEnd < #races) then
               raceDisplayedStart = raceDisplayedStart + 1
               raceDisplayedEnd = raceDisplayedEnd + 1
            else
               keepscrolling = ""
            end
         end
         wait.time(0.1)
         forceRedraw()
      end
   end
   )
end

function scrollbar2()
   wait.make(
   function()
      while keepscrolling == "rightup" or keepscrolling == "rightdown" do
         if keepscrolling == "rightup" then
            if (textStart > 1) then
               textStart = textStart - 1
               textEnd = textEnd - 1
            else
                 keepscrolling = ""
            end
         elseif keepscrolling == "rightdown" then
            if (textEnd < #text) then
               textStart = textStart + 1
               textEnd = textEnd + 1
            else
               keepscrolling = ""
            end
         end
         wait.time(0.1)
         forceRedraw()
      end
   end
   )
end

function OnPluginInstall () 
  
  font_name = GetVariable("font_name") or default_font_name
  font_size = tonumber(GetVariable("font_size")) or default_font_size
	
  -- get default config
  if not config then
    config = default_config
  end
  
  --- Setup the windows
  SetUpHotspotsAndDraw(true)

   
  -- add the fonts                
  --check(WindowFont (win, font, font_name, font_size, true, false, false, false))
  
    
end -- OnPluginInstall
--================================================================================
-- Called by OnPluginInstall, but also by redraw routine to refresh the screen
-- and (if the first time) add the resizer tag, otherwise move the resizer relative
-- to the main window.
--=================================================================================
function SetUpHotspotsAndDraw(firstTime)
	if (firstTime) then
    
		WindowCreate (win, 0, 0, config.width, config.height, miniwin.pos_center_all, 0, ColourNameToRGB("black")) -- create window
		windowinfo = movewindow.install (win, 6) -- default to 6 (on top right)
		check(WindowFont (win, font, font_name, font_size, false, false, false, false))
    -- spacing stuff
    titleHeight = WindowFontInfo(win, font, 1)+4
    raceLineHeight = WindowFontInfo(win, font, 1)+spacer
    textLineHeight = WindowFontInfo(win, font, 1)+1
    
    --effectiveWidth = math.min(config.width, GetInfo(281)-windowinfo.window_left)
		WindowAddHotspot (win, "resize", config.width-RESIZE_TAG_SIZE, config.height-RESIZE_TAG_SIZE, config.width, config.height, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 6, 0)
		WindowDragHandler(win, "resize", "ResizeMoveCallback", "ResizeReleaseCallback", 0)
    WindowAddHotspot (win, "splitmove", config.split-1, titleHeight, config.split+1, config.height-1, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 8, 0)
    WindowDragHandler(win, "splitmove", "SplitMoveCallback", "SplitReleaseCallback", 0)
    -- make background hotspots for scrolling
    WindowAddHotspot (win, "leftbackground", 2, titleHeight, config.split-SCROLL_BAR_WIDTH-2, config.height-2, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "",0, 0)
    WindowScrollwheelHandler(win, "leftbackground", "wheel_move")
    -- left scroll bar up/down buttons
    WindowAddHotspot(win, "leftup", config.split-1-SCROLL_BAR_WIDTH, titleHeight, config.split-1, titleHeight+SCROLL_BAR_WIDTH, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)
    WindowAddHotspot(win, "leftdown", config.split-1-SCROLL_BAR_WIDTH, config.height-SCROLL_BAR_WIDTH, config.split-1, config.height, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)

    WindowAddHotspot (win, "rightbackground", config.split+2, titleHeight, config.width-SCROLL_BAR_WIDTH-2, config.height-2, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "",0, 0)    
    WindowScrollwheelHandler(win, "rightbackground", "wheel_move")
    -- right scroll bar up/down buttons
    WindowAddHotspot(win, "rightup", config.width-SCROLL_BAR_WIDTH, titleHeight, config.width-2, titleHeight+SCROLL_BAR_WIDTH, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)
    WindowAddHotspot(win, "rightdown", config.width-SCROLL_BAR_WIDTH, config.height-(2*SCROLL_BAR_WIDTH), config.width-2, config.height-SCROLL_BAR_WIDTH, "MouseOver", "CancelMouseOver", "MouseDown", "CancelMouseDown", "MouseUp", "", 1, 0)

	else -- not our first time drawing
		-- everything has already been made
		-- just move them back into place
		--effectiveWidth = math.min(config.width, GetInfo(281)-windowinfo.window_left)
		WindowResize(win, config.width, config.height, 0x000000)
		WindowMoveHotspot(win, "resize", config.width-RESIZE_TAG_SIZE, config.height-RESIZE_TAG_SIZE, config.width, config.height)
    WindowMoveHotspot(win, "splitmove", config.split-1, WindowFontInfo(win, font, 1)+4, config.split+1, config.height-1)
    
    WindowMoveHotspot(win, "leftbackground", 2, WindowFontInfo(win, font, 1)+4, config.split-SCROLL_BAR_WIDTH-2, config.height-2)
    WindowMoveHotspot(win, "rightbackground", config.split+2, titleHeight, config.width-SCROLL_BAR_WIDTH-2, config.height-2)
    WindowMoveHotspot(win, "leftup",config.split-1-SCROLL_BAR_WIDTH, titleHeight, config.split-1, titleHeight+SCROLL_BAR_WIDTH)
    WindowMoveHotspot(win, "leftdown",config.split-1-SCROLL_BAR_WIDTH, config.height-SCROLL_BAR_WIDTH, config.split-1, config.height)
    WindowMoveHotspot(win, "rightup",config.width-SCROLL_BAR_WIDTH, titleHeight, config.width-2, titleHeight+SCROLL_BAR_WIDTH)
    WindowMoveHotspot(win, "rightdown",config.width-SCROLL_BAR_WIDTH, config.height-(2*SCROLL_BAR_WIDTH), config.width-2, config.height-SCROLL_BAR_WIDTH)
	end
  
  -- left window
  racesFit = math.ceil((config.height-titleHeight)/raceLineHeight)
  
  raceDisplayedStart = 1
  raceDisplayedEnd = math.min(racesFit, #races)
  -- right window
  textFit = math.ceil((config.height-titleHeight-4)/textLineHeight)
  
  textStart = 1
  textEnd = math.min(textFit, #text)
    
  redraw_scheduled = true
  drawWindows()
end


function drawWindows()
	if redraw_scheduled == false then
		return
	else
		redraw_scheduled = false
	end
  if visible == "true" then
    drawWindow()
  end
end
function drawResizer(window, winwidth, winheight)
   -- draw the resize widget bottom right corner.
   WindowRectOp(win, 2, winwidth-SCROLL_BAR_WIDTH, winheight-SCROLL_BAR_WIDTH, 0, 0, SCROLL_BACKGROUND_COLOUR) -- resizer background
   WindowLine(window, winwidth-3, winheight-2, winwidth-2, winheight-3, 0xffffff, 0, 2)
   WindowLine(window, winwidth-4, winheight-2, winwidth-2, winheight-4, 0x696969, 0, 1)
   WindowLine(window, winwidth-6, winheight-2, winwidth-2, winheight-6, 0xffffff, 0, 2)
   WindowLine(window, winwidth-7, winheight-2, winwidth-2, winheight-7, 0x696969, 0, 1)
   WindowLine(window, winwidth-9, winheight-2, winwidth-2, winheight-9, 0xffffff, 0, 2)
   WindowLine(window, winwidth-10, winheight-2, winwidth-2, winheight-10, 0x696969, 0, 1)
   WindowLine(window, winwidth-12, winheight-2, winwidth-2, winheight-12, 0xffffff, 0, 2)
   WindowLine(window, winwidth-13, winheight-2, winwidth-2, winheight-13, 0x696969, 0, 1)
end

function OnPluginSaveState ()
  movewindow.save_state (win)
  SetVariable("config", serialize.save("config"))
  SetVariable("races", serialize.save("races"))
  SetVariable("visible", visible)
end -- function OnPluginSaveState

function OnPluginDisable()
  WindowShow(win, false)
end

  ]]> 
  </script>
  </muclient>
 